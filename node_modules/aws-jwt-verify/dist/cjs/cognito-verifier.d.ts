import { JwtRsaVerifierBase, JwtRsaVerifierProperties } from "./jwt-rsa.js";
import { JwksCache, Jwks, Jwk } from "./jwk.js";
import { JwtHeader, JwtPayload, CognitoIdOrAccessTokenPayload } from "./jwt-model.js";
import { StillToProvideVerifyProps, WithoutOptionalFields } from "./typing-util.js";
interface CognitoVerifyProperties {
    /**
     * The client ID that you expect to be present on the JWT
     * (In the ID token's aud claim, or the Access token's client_id claim).
     * If you provide a string array, that means at least one of those client IDs
     * must be present on the JWT.
     * Pass null explicitly to not check the JWT's client ID--if you know what you're doing
     */
    clientId: string | string[] | null;
    /**
     * The token use that you expect to be present in the JWT's token_use claim.
     * Usually you are verifying either Access token (common) or ID token (less common).
     * Pass null explicitly to not check the JWT's token use--if you know what you're doing
     */
    tokenUse: "id" | "access" | null;
    /**
     * The group that you expect to be present in the JWT's "cognito:groups" claim.
     * If you provide a string array, that means at least one of those groups
     * must be present in the JWT's "cognito:groups" claim.
     */
    groups?: string | string[] | null;
    /**
     * The scope that you expect to be present in the JWT's scope claim.
     * If you provide a string array, that means at least one of those scopes
     * must be present in the JWT's scope claim.
     */
    scope?: string | string[] | null;
    /**
     * The number of seconds after expiration (exp claim) or before not-before (nbf claim) that you will allow
     * (use this to account for clock differences between systems)
     */
    graceSeconds?: number;
    /**
     * Your custom function with checks. It will be called, at the end of the verification,
     * after standard verifcation checks have all passed.
     * Throw an error in this function if you want to reject the JWT for whatever reason you deem fit.
     * Your function will be called with a properties object that contains:
     * - the decoded JWT header
     * - the decoded JWT payload
     * - the JWK that was used to verify the JWT's signature
     */
    customJwtCheck?: (props: {
        header: JwtHeader;
        payload: JwtPayload;
        jwk: Jwk;
    }) => Promise<void> | void;
}
/** Interface for Cognito JWT verifier properties, for a single User Pool */
interface CognitoJwtVerifierProperties extends Partial<CognitoVerifyProperties> {
    /** The User Pool whose JWTs you want to verify */
    userPoolId: string;
}
/**
 * Interface for Cognito JWT verifier properties, when multiple User Pools are used in the verifier.
 * In this case, you should be explicit in mapping `clientId` to User Pool.
 */
interface CognitoJwtVerifierMultiProperties extends CognitoVerifyProperties {
    /** The User Pool whose JWTs you want to verify */
    userPoolId: string;
}
/**
 * Class representing a verifier for JWTs signed by Amazon Cognito
 */
export declare class CognitoJwtVerifier<StillToProvide extends Partial<CognitoVerifyProperties>, IssuerConfig extends JwtRsaVerifierProperties & CognitoJwtVerifierProperties, MultiIssuer extends boolean> extends JwtRsaVerifierBase<StillToProvide, CognitoVerifyProperties, IssuerConfig, MultiIssuer> {
    private constructor();
    /**
     * Parse a User Pool ID, to extract the issuer and JWKS URI
     *
     * @param userPoolId The User Pool ID
     * @returns The issuer and JWKS URI for the User Pool
     */
    static parseUserPoolId(userPoolId: string): {
        issuer: string;
        jwksUri: string;
    };
    /**
     * Create a Cognito JWT verifier for a single User Pool
     *
     * @param verifyProperties The verification properties for your User Pool
     * @param additionalProperties Additional properties
     * @param additionalProperties.jwksCache Overriding JWKS cache that you want to use
     * @returns An Cognito JWT Verifier instance, that you can use to verify Cognito signed JWTs with
     */
    static create<T extends CognitoJwtVerifierProperties>(props: T, additionalProperties?: {
        jwksCache: JwksCache;
    }): CognitoJwtVerifier<StillToProvideVerifyProps<WithoutOptionalFields<CognitoVerifyProperties>, typeof props> & Partial<CognitoVerifyProperties>, T & JwtRsaVerifierProperties, false>;
    /**
     * Create a Cognito JWT verifier for multiple User Pools
     *
     * @param verifyProperties An array of verification properties, one for each User Pool
     * @param additionalProperties Additional properties
     * @param additionalProperties.jwksCache Overriding JWKS cache that you want to use
     * @returns An Cognito JWT Verifier instance, that you can use to verify Cognito signed JWTs with
     */
    static create<T extends CognitoJwtVerifierMultiProperties>(props: T[], additionalProperties?: {
        jwksCache: JwksCache;
    }): CognitoJwtVerifier<Partial<CognitoVerifyProperties>, T & JwtRsaVerifierProperties, true>;
    /**
     * Verify (synchronously) a JWT that is signed by Amazon Cognito.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown
     */
    verifySync<OptionalProps extends Partial<CognitoVerifyProperties>, MandatoryProps extends StillToProvide>(...args: {
        [key: string]: never;
    } extends StillToProvide ? [jwt: string, props?: OptionalProps] : [jwt: string, props: MandatoryProps]): CognitoIdOrAccessTokenPayload<IssuerConfig, {
        [key: string]: never;
    } extends StillToProvide ? OptionalProps : MandatoryProps>;
    /**
     * Verify (asynchronously) a JWT that is signed by Amazon Cognito.
     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,
     * in case it is not yet available in the cache.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
     */
    verify<OptionalProps extends Partial<CognitoVerifyProperties>, MandatoryProps extends StillToProvide>(...args: {
        [key: string]: never;
    } extends StillToProvide ? [jwt: string, props?: OptionalProps] : [jwt: string, props: MandatoryProps]): Promise<CognitoIdOrAccessTokenPayload<IssuerConfig, {
        [key: string]: never;
    } extends StillToProvide ? OptionalProps : MandatoryProps>>;
    /**
     * This method loads a JWKS that you provide, into the JWKS cache, so that it is
     * available for JWT verification. Use this method to speed up the first JWT verification
     * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS
     * in case the JwtVerifier does not have internet access to download the JWKS
     *
     * @param jwks The JWKS
     * @param userPoolId The userPoolId for which you want to cache the JWKS
     *  Supply this field, if you instantiated the CognitoJwtVerifier with multiple userPoolIds
     * @returns void
     */
    cacheJwks(...args: MultiIssuer extends false ? [jwks: Jwks, userPoolId?: string] : [jwks: Jwks, userPoolId: string]): void;
}
export {};
