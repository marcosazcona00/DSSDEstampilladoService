"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyObjectCache = exports.transformJwkToKeyObject = exports.JwtRsaVerifier = exports.JwtRsaVerifierBase = exports.verifyJwtSync = exports.verifyJwt = void 0;
const crypto_1 = require("crypto");
const url_1 = require("url");
const path_1 = require("path");
const jwk_js_1 = require("./jwk.js");
const asn1_js_1 = require("./asn1.js");
const assert_js_1 = require("./assert.js");
const jwt_js_1 = require("./jwt.js");
const error_js_1 = require("./error.js");
/**
 * Verify a JWTs signature agains a JWK. This function throws an error if the JWT is not valid
 *
 * @param header The decoded and JSON parsed JWT header
 * @param headerB64 The JWT header in base64 encoded form
 * @param payload The decoded and JSON parsed JWT payload
 * @param payloadB64 The JWT payload in base64 encoded form
 * @param signatureB64 The JWT signature in base64 encoded form
 * @param jwk The JWK with which the JWT was signed
 * @param jwkToKeyObjectTransformer Function to transform the JWK into a NodeJS native key object
 * @returns void
 */
function verifySignatureAgainstJwk(header, headerB64, payload, payloadB64, signatureB64, jwk, jwkToKeyObjectTransformer = exports.transformJwkToKeyObject) {
    // Check JWK use
    (0, assert_js_1.assertStringEquals)("JWK use", jwk.use, "sig");
    // Check that JWT signature algorithm matches JWK
    (0, assert_js_1.assertStringEquals)("JWT signature algorithm", header.alg, jwk.alg);
    // Check JWT signature algorithm is RS256
    (0, assert_js_1.assertStringEquals)("JWT signature algorithm", header.alg, "RS256");
    // Convert JWK modulus and exponent into DER public key
    const publicKey = jwkToKeyObjectTransformer(jwk, payload.iss, header.kid);
    // Verify the JWT signature
    // RS256 is known in OpenSSL as RSA-SHA256
    const valid = (0, crypto_1.createVerify)("RSA-SHA256")
        .update(`${headerB64}.${payloadB64}`)
        .verify(publicKey, signatureB64, "base64");
    if (!valid) {
        throw new error_js_1.JwtInvalidSignatureError("Invalid signature");
    }
}
/**
 * Verify a JWT asynchronously (thus allowing for the JWKS to be fetched from the JWKS URI)
 *
 * @param jwt The JWT
 * @param jwksUri The JWKS URI, where the JWKS can be fetched from
 * @param options Verification options
 * @param jwkFetcher A function that can execute the fetch of the JWKS from the JWKS URI
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
 */
async function verifyJwt(jwt, jwksUri, options, jwkFetcher, jwkToKeyObjectTransformer) {
    return verifyDecomposedJwt((0, jwt_js_1.decomposeJwt)(jwt), jwksUri, options, jwkFetcher, jwkToKeyObjectTransformer);
}
exports.verifyJwt = verifyJwt;
/**
 * Verify (asynchronously) a JWT that is already decomposed (by function `decomposeJwt`)
 *
 * @param decomposedJwt The decomposed JWT
 * @param jwksUri The JWKS URI, where the JWKS can be fetched from
 * @param options Verification options
 * @param jwkFetcher A function that can execute the fetch of the JWKS from the JWKS URI
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
 */
async function verifyDecomposedJwt(decomposedJwt, jwksUri, options, jwkFetcher = jwk_js_1.fetchJwk, jwkToKeyObjectTransformer) {
    const { header, headerB64, payload, payloadB64, signatureB64 } = decomposedJwt;
    (0, jwt_js_1.validateJwtFields)(payload, options);
    const jwk = await jwkFetcher(jwksUri, decomposedJwt);
    verifySignatureAgainstJwk(header, headerB64, payload, payloadB64, signatureB64, jwk, jwkToKeyObjectTransformer);
    if (options.customJwtCheck) {
        await options.customJwtCheck({ header, payload, jwk });
    }
    return payload;
}
/**
 * Verify a JWT synchronously, using a JWKS or JWK that has already been fetched
 *
 * @param jwt The JWT
 * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly
 * @param options Verification options
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns The (JSON parsed) payload of the JWT––if the JWT is valid, otherwise an error is thrown
 */
function verifyJwtSync(jwt, jwkOrJwks, options, jwkToKeyObjectTransformer) {
    return verifyDecomposedJwtSync((0, jwt_js_1.decomposeJwt)(jwt), jwkOrJwks, options, jwkToKeyObjectTransformer);
}
exports.verifyJwtSync = verifyJwtSync;
/**
 * Verify (synchronously) a JWT that is already decomposed (by function `decomposeJwt`)
 *
 * @param decomposedJwt The decomposed JWT
 * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly
 * @param options Verification options
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns The (JSON parsed) payload of the JWT––if the JWT is valid, otherwise an error is thrown
 */
function verifyDecomposedJwtSync(decomposedJwt, jwkOrJwks, options, jwkToKeyObjectTransformer) {
    const { header, headerB64, payload, payloadB64, signatureB64 } = decomposedJwt;
    (0, jwt_js_1.validateJwtFields)(payload, options);
    let jwk;
    if ((0, jwk_js_1.isJwk)(jwkOrJwks)) {
        jwk = jwkOrJwks;
    }
    else if ((0, jwk_js_1.isJwks)(jwkOrJwks)) {
        const locatedJwk = jwkOrJwks.keys.find((key) => key.kid === header.kid);
        if (!locatedJwk) {
            throw new error_js_1.KidNotFoundInJwksError(`JWK for kid ${header.kid} not found in the JWKS`);
        }
        jwk = locatedJwk;
    }
    else {
        throw new error_js_1.ParameterValidationError([
            `Expected a valid JWK or JWKS (parsed as JavaScript object), but received: ${jwkOrJwks}.`,
            "If you're passing a JWKS URI, use the async verify() method instead, it will download and parse the JWKS for you",
        ].join());
    }
    verifySignatureAgainstJwk(header, headerB64, payload, payloadB64, signatureB64, jwk, jwkToKeyObjectTransformer);
    if (options.customJwtCheck) {
        const res = options.customJwtCheck({ header, payload, jwk });
        if (res !== undefined && res instanceof Promise) {
            throw new error_js_1.ParameterValidationError("Custom JWT checks must be synchronous but a promise was returned");
        }
    }
    return payload;
}
/**
 * Abstract class representing a verifier for JWTs signed with RSA (e.g. RS256)
 *
 * A class is used, because there is state:
 * - The JWKS is fetched (downloaded) from the JWKS URI and cached in memory
 * - Verification properties at verifier level, are used as default options for individual verify calls
 *
 * When instantiating this class, relevant type parameters should be provided, for your concrete case:
 * @param StillToProvide The verification options that you want callers of verify to provide on individual verify calls
 * @param SpecificVerifyProperties The verification options that you'll use
 * @param IssuerConfig The issuer config that you'll use (config options are used as default verification options)
 * @param MultiIssuer Verify multiple issuers (true) or just a single one (false)
 */
class JwtRsaVerifierBase {
    constructor(verifyProperties, jwksCache = new jwk_js_1.SimpleJwksCache()) {
        this.jwksCache = jwksCache;
        this.issuersConfig = new Map();
        this.publicKeyCache = new KeyObjectCache();
        if (Array.isArray(verifyProperties)) {
            if (!verifyProperties.length) {
                throw new error_js_1.ParameterValidationError("Provide at least one issuer configuration");
            }
            for (const prop of verifyProperties) {
                if (this.issuersConfig.has(prop.issuer)) {
                    throw new error_js_1.ParameterValidationError(`issuer ${prop.issuer} supplied multiple times`);
                }
                this.issuersConfig.set(prop.issuer, this.withJwksUri(prop));
            }
        }
        else {
            this.issuersConfig.set(verifyProperties.issuer, this.withJwksUri(verifyProperties));
        }
    }
    get expectedIssuers() {
        return Array.from(this.issuersConfig.keys());
    }
    getIssuerConfig(issuer) {
        if (!issuer) {
            if (this.issuersConfig.size !== 1) {
                throw new error_js_1.ParameterValidationError("issuer must be provided");
            }
            issuer = this.issuersConfig.keys().next().value;
        }
        const config = this.issuersConfig.get(issuer);
        if (!config) {
            throw new error_js_1.ParameterValidationError(`issuer not configured: ${issuer}`);
        }
        return config;
    }
    /**
     * This method loads a JWKS that you provide, into the JWKS cache, so that it is
     * available for JWT verification. Use this method to speed up the first JWT verification
     * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS
     * in case the JwtVerifier does not have internet access to download the JWKS
     *
     * @param jwksThe JWKS
     * @param issuer The issuer for which you want to cache the JWKS
     *  Supply this field, if you instantiated the JwtVerifier with multiple issuers
     * @returns void
     */
    cacheJwks(...args) {
        const issuerConfig = this.getIssuerConfig(args[1]);
        this.jwksCache.addJwks(issuerConfig.jwksUri, args[0]);
        this.publicKeyCache.clearCache(issuerConfig.issuer);
    }
    /**
     * Hydrate the JWKS cache for (all of) the configured issuer(s).
     * This will fetch and cache the latest and greatest JWKS for concerned issuer(s).
     *
     * @param issuer The issuer to fetch the JWKS for
     * @returns void
     */
    async hydrate() {
        const jwksFetches = this.expectedIssuers
            .map((issuer) => this.getIssuerConfig(issuer).jwksUri)
            .map((jwksUri) => this.jwksCache.getJwks(jwksUri));
        await Promise.all(jwksFetches);
    }
    /**
     * Verify (synchronously) a JWT that is signed using RS256.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown
     */
    verifySync(...args) {
        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(args[0], args[1]);
        const jwk = this.jwksCache.getCachedJwk(jwksUri, decomposedJwt);
        return verifyDecomposedJwtSync(decomposedJwt, jwk, verifyProperties, this.publicKeyCache.transformJwkToKeyObject.bind(this.publicKeyCache));
    }
    /**
     * Verify (asynchronously) a JWT that is signed using RS256.
     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,
     * in case it is not yet available in the cache.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
     */
    async verify(...args) {
        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(args[0], args[1]);
        return verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties, this.jwksCache.getJwk.bind(this.jwksCache), this.publicKeyCache.transformJwkToKeyObject.bind(this.publicKeyCache));
    }
    /**
     * Get the verification parameters to use, by merging the issuer configuration,
     * with the overriding properties that are now provided
     *
     * @param jwt: the JWT that is going to be verified
     * @param verifyProperties: the overriding properties, that override the issuer configuration
     * @returns The merged verification parameters
     */
    getVerifyParameters(jwt, verifyProperties) {
        const decomposedJwt = (0, jwt_js_1.decomposeJwt)(jwt);
        if (!decomposedJwt.payload.iss) {
            throw new error_js_1.JwtInvalidClaimError("JWT payload does not have iss claim");
        }
        (0, assert_js_1.assertStringArrayContainsString)("Issuer", decomposedJwt.payload.iss, this.expectedIssuers);
        const issuerConfig = this.getIssuerConfig(decomposedJwt.payload.iss);
        return {
            decomposedJwt,
            jwksUri: issuerConfig.jwksUri,
            verifyProperties: {
                ...issuerConfig,
                ...verifyProperties,
            },
        };
    }
    /**
     * Get issuer config with JWKS URI, by adding a default JWKS URI if needed
     *
     * @param config: the issuer config.
     * @returns The config with JWKS URI
     */
    withJwksUri(config) {
        if (config.jwksUri) {
            return config;
        }
        const issuerUri = new url_1.URL(config.issuer);
        return {
            jwksUri: new url_1.URL((0, path_1.join)(issuerUri.pathname, "/.well-known/jwks.json"), config.issuer).href,
            ...config,
        };
    }
}
exports.JwtRsaVerifierBase = JwtRsaVerifierBase;
/**
 * Class representing a verifier for JWTs signed with RSA (e.g. RS256)
 */
class JwtRsaVerifier extends JwtRsaVerifierBase {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    static create(verifyProperties, additionalProperties) {
        return new this(verifyProperties, additionalProperties?.jwksCache);
    }
}
exports.JwtRsaVerifier = JwtRsaVerifier;
/**
 * Transform the JWK into an RSA public key in NodeJS native key object format
 *
 * @param jwk: the JWK
 * @returns the RSA public key in NodeJS native key object format
 */
const transformJwkToKeyObject = (jwk) => (0, crypto_1.createPublicKey)({
    key: (0, asn1_js_1.constructPublicKeyInDerFormat)(Buffer.from(jwk.n, "base64"), Buffer.from(jwk.e, "base64")),
    format: "der",
    type: "spki",
});
exports.transformJwkToKeyObject = transformJwkToKeyObject;
/**
 * Class representing a cache of RSA public keys in NodeJS native key object format
 *
 * Because it takes a bit of compute time to turn a JWK into NodeJS native key object format,
 * we want to cache this computation.
 */
class KeyObjectCache {
    constructor(jwkToKeyObjectTransformer = exports.transformJwkToKeyObject) {
        this.jwkToKeyObjectTransformer = jwkToKeyObjectTransformer;
        this.publicKeys = new Map();
    }
    /**
     * Transform the JWK into an RSA public key in NodeJS native key object format.
     * If the transformed JWK is already in the cache, it is returned from the cache instead.
     * The cache keys are: issuer, JWK kid (key id)
     *
     * @param jwk: the JWK
     * @param issuer: the issuer that uses the JWK for signing JWTs
     * @returns the RSA public key in NodeJS native key object format
     */
    transformJwkToKeyObject(jwk, issuer) {
        if (!issuer) {
            return this.jwkToKeyObjectTransformer(jwk);
        }
        const cachedPublicKey = this.publicKeys.get(issuer)?.get(jwk.kid);
        if (cachedPublicKey) {
            return cachedPublicKey;
        }
        const publicKey = this.jwkToKeyObjectTransformer(jwk);
        const cachedIssuer = this.publicKeys.get(issuer);
        if (cachedIssuer) {
            cachedIssuer.set(jwk.kid, publicKey);
        }
        else {
            this.publicKeys.set(issuer, new Map([[jwk.kid, publicKey]]));
        }
        return publicKey;
    }
    clearCache(issuer) {
        this.publicKeys.delete(issuer);
    }
}
exports.KeyObjectCache = KeyObjectCache;
