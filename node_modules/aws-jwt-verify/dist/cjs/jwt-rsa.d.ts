/// <reference types="node" />
import { KeyObject } from "crypto";
import { JwksCache, Jwk, Jwks } from "./jwk.js";
import { JwtHeader, JwtPayload } from "./jwt-model.js";
import { StillToProvideVerifyProps, WithoutOptionalFields } from "./typing-util.js";
import { decomposeJwt } from "./jwt.js";
/** Interface for JWT verification properties */
interface VerifyProperties {
    /**
     * The audience that you expect to be present in the JWT's aud claim.
     * If you provide a string array, that means at least one of those audiences
     * must be present in the JWT's aud claim.
     * Pass null explicitly to not check the JWT's audience--if you know what you're doing
     */
    audience: string | string[] | null;
    /**
     * The scope that you expect to be present in the JWT's scope claim.
     * If you provide a string array, that means at least one of those scopes
     * must be present in the JWT's scope claim.
     */
    scope?: string | string[];
    /**
     * The number of seconds after expiration (exp claim) or before not-before (nbf claim) that you will allow
     * (use this to account for clock differences between systems)
     */
    graceSeconds?: number;
    /**
     * Your custom function with checks. It will be called, at the end of the verification,
     * after standard verifcation checks have all passed.
     * Throw an error in this function if you want to reject the JWT for whatever reason you deem fit.
     * Your function will be called with a properties object that contains:
     * - the decoded JWT header
     * - the decoded JWT payload
     * - the JWK that was used to verify the JWT's signature
     */
    customJwtCheck?: (props: {
        header: JwtHeader;
        payload: JwtPayload;
        jwk: Jwk;
    }) => Promise<void> | void;
}
/** Interface for JWT RSA verifier properties, for a single issuer */
export interface JwtRsaVerifierProperties extends Partial<VerifyProperties> {
    /**
     * URI where the JWKS (JSON Web Key Set) can be downloaded from.
     * The JWKS contains one or more JWKs, which represent the public keys with which
     * JWTs have been signed.
     */
    jwksUri?: string;
    /**
     * The issuer of the JWTs you want to verify.
     * Set this to the expected value of the `iss` claim in the JWT.
     */
    issuer: string;
}
/**
 * Interface for JWT RSA verifier properties, when multiple issuers are used in the verifier.
 * In this case, you should be explicit in mapping audience to issuer.
 */
interface JwtRsaVerifierMultiProperties extends VerifyProperties {
    /**
     * URI where the JWKS (JSON Web Key Set) can be downloaded from.
     * The JWKS contains one or more JWKs, which represent the public keys with which
     * JWTs have been signed.
     */
    jwksUri?: string;
    /**
     * The issuer of the JWTs you want to verify.
     * Set this to the expected value of the `iss` claim in the JWT.
     */
    issuer: string;
}
/**
 * Verify a JWT asynchronously (thus allowing for the JWKS to be fetched from the JWKS URI)
 *
 * @param jwt The JWT
 * @param jwksUri The JWKS URI, where the JWKS can be fetched from
 * @param options Verification options
 * @param jwkFetcher A function that can execute the fetch of the JWKS from the JWKS URI
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
 */
export declare function verifyJwt(jwt: string, jwksUri: string, options: {
    issuer: string | string[] | null;
    audience: string | string[] | null;
    scope?: string | string[];
    graceSeconds?: number;
    customJwtCheck?: (props: {
        header: JwtHeader;
        payload: JwtPayload;
        jwk: Jwk;
    }) => Promise<void> | void;
}, jwkFetcher?: (jwksUri: string, decomposedJwt: ReturnType<typeof decomposeJwt>) => Promise<Jwk>, jwkToKeyObjectTransformer?: JwkToKeyObjectTransformer): Promise<JwtPayload>;
/**
 * Verify a JWT synchronously, using a JWKS or JWK that has already been fetched
 *
 * @param jwt The JWT
 * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly
 * @param options Verification options
 * @param jwkToKeyObjectTransformer A function that can transform a JWK into a NodeJS native key object
 * @returns The (JSON parsed) payload of the JWT––if the JWT is valid, otherwise an error is thrown
 */
export declare function verifyJwtSync(jwt: string, jwkOrJwks: Jwk | Jwks, options: {
    issuer: string | string[] | null;
    audience: string | string[] | null;
    scope?: string | string[];
    graceSeconds?: number;
    customJwtCheck?: (props: {
        header: JwtHeader;
        payload: JwtPayload;
        jwk: Jwk;
    }) => void;
}, jwkToKeyObjectTransformer?: JwkToKeyObjectTransformer): JwtPayload;
/** Type alias for better readability below */
declare type Issuer = string;
/**
 * Abstract class representing a verifier for JWTs signed with RSA (e.g. RS256)
 *
 * A class is used, because there is state:
 * - The JWKS is fetched (downloaded) from the JWKS URI and cached in memory
 * - Verification properties at verifier level, are used as default options for individual verify calls
 *
 * When instantiating this class, relevant type parameters should be provided, for your concrete case:
 * @param StillToProvide The verification options that you want callers of verify to provide on individual verify calls
 * @param SpecificVerifyProperties The verification options that you'll use
 * @param IssuerConfig The issuer config that you'll use (config options are used as default verification options)
 * @param MultiIssuer Verify multiple issuers (true) or just a single one (false)
 */
export declare abstract class JwtRsaVerifierBase<StillToProvide extends Partial<SpecificVerifyProperties>, SpecificVerifyProperties, IssuerConfig extends {
    issuer: string;
    jwksUri?: string;
} & Partial<SpecificVerifyProperties>, MultiIssuer extends boolean> {
    private jwksCache;
    private issuersConfig;
    private publicKeyCache;
    protected constructor(verifyProperties: IssuerConfig | IssuerConfig[], jwksCache?: JwksCache);
    protected get expectedIssuers(): string[];
    protected getIssuerConfig(issuer?: string): IssuerConfig & {
        jwksUri: string;
    };
    /**
     * This method loads a JWKS that you provide, into the JWKS cache, so that it is
     * available for JWT verification. Use this method to speed up the first JWT verification
     * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS
     * in case the JwtVerifier does not have internet access to download the JWKS
     *
     * @param jwksThe JWKS
     * @param issuer The issuer for which you want to cache the JWKS
     *  Supply this field, if you instantiated the JwtVerifier with multiple issuers
     * @returns void
     */
    cacheJwks(...args: MultiIssuer extends false ? [jwks: Jwks, issuer?: string] : [jwks: Jwks, issuer: string]): void;
    /**
     * Hydrate the JWKS cache for (all of) the configured issuer(s).
     * This will fetch and cache the latest and greatest JWKS for concerned issuer(s).
     *
     * @param issuer The issuer to fetch the JWKS for
     * @returns void
     */
    hydrate(): Promise<void>;
    /**
     * Verify (synchronously) a JWT that is signed using RS256.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns The payload of the JWT––if the JWT is valid, otherwise an error is thrown
     */
    verifySync(...args: {
        [key: string]: never;
    } extends StillToProvide ? [jwt: string, props?: Partial<SpecificVerifyProperties>] : [jwt: string, props: StillToProvide]): JwtPayload;
    /**
     * Verify (asynchronously) a JWT that is signed using RS256.
     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,
     * in case it is not yet available in the cache.
     *
     * @param jwt The JWT, as string
     * @param props Verification properties
     * @returns Promise that resolves to the payload of the JWT––if the JWT is valid, otherwise the promise rejects
     */
    verify(...args: {
        [key: string]: never;
    } extends StillToProvide ? [jwt: string, props?: Partial<SpecificVerifyProperties>] : [jwt: string, props: StillToProvide]): Promise<JwtPayload>;
    /**
     * Get the verification parameters to use, by merging the issuer configuration,
     * with the overriding properties that are now provided
     *
     * @param jwt: the JWT that is going to be verified
     * @param verifyProperties: the overriding properties, that override the issuer configuration
     * @returns The merged verification parameters
     */
    private getVerifyParameters;
    /**
     * Get issuer config with JWKS URI, by adding a default JWKS URI if needed
     *
     * @param config: the issuer config.
     * @returns The config with JWKS URI
     */
    private withJwksUri;
}
/**
 * Class representing a verifier for JWTs signed with RSA (e.g. RS256)
 */
export declare class JwtRsaVerifier<StillToProvide extends Partial<VerifyProperties>, IssuerConfig extends JwtRsaVerifierProperties, MultiIssuer extends boolean> extends JwtRsaVerifierBase<StillToProvide, VerifyProperties, IssuerConfig, MultiIssuer> {
    /**
     * Create an RSA JWT verifier for a single issuer
     *
     * @param verifyProperties The verification properties for your issuer
     * @param additionalProperties Additional properties
     * @param additionalProperties.jwksCache Overriding JWKS cache that you want to use
     * @returns An RSA JWT Verifier instance, that you can use to verify JWTs with
     */
    static create<T extends JwtRsaVerifierProperties>(verifyProperties: T, additionalProperties?: {
        jwksCache: JwksCache;
    }): JwtRsaVerifierBase<StillToProvideVerifyProps<WithoutOptionalFields<VerifyProperties>, typeof verifyProperties> & Partial<VerifyProperties>, VerifyProperties, JwtRsaVerifierProperties, false>;
    /**
     * Create an RSA JWT verifier for multiple issuer
     *
     * @param verifyProperties An array of verification properties, one for each issuer
     * @param additionalProperties Additional properties
     * @param additionalProperties.jwksCache Overriding JWKS cache that you want to use
     * @returns An RSA JWT Verifier instance, that you can use to verify JWTs with
     */
    static create<T extends JwtRsaVerifierMultiProperties>(verifyProperties: T[], additionalProperties?: {
        jwksCache: JwksCache;
    }): JwtRsaVerifierBase<Partial<VerifyProperties>, VerifyProperties, JwtRsaVerifierMultiProperties, true>;
}
/** Interface for functions that can transform a JWK into an RSA public key in NodeJS native key object format */
export declare type JwkToKeyObjectTransformer = (jwk: Jwk, issuer?: string, kid?: string) => KeyObject;
/**
 * Transform the JWK into an RSA public key in NodeJS native key object format
 *
 * @param jwk: the JWK
 * @returns the RSA public key in NodeJS native key object format
 */
export declare const transformJwkToKeyObject: JwkToKeyObjectTransformer;
/**
 * Class representing a cache of RSA public keys in NodeJS native key object format
 *
 * Because it takes a bit of compute time to turn a JWK into NodeJS native key object format,
 * we want to cache this computation.
 */
export declare class KeyObjectCache {
    jwkToKeyObjectTransformer: JwkToKeyObjectTransformer;
    private publicKeys;
    constructor(jwkToKeyObjectTransformer?: JwkToKeyObjectTransformer);
    /**
     * Transform the JWK into an RSA public key in NodeJS native key object format.
     * If the transformed JWK is already in the cache, it is returned from the cache instead.
     * The cache keys are: issuer, JWK kid (key id)
     *
     * @param jwk: the JWK
     * @param issuer: the issuer that uses the JWK for signing JWTs
     * @returns the RSA public key in NodeJS native key object format
     */
    transformJwkToKeyObject(jwk: Jwk, issuer?: Issuer): KeyObject;
    clearCache(issuer: Issuer): void;
}
export {};
